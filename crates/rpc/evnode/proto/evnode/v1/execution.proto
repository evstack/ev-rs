syntax = "proto3";
package evnode.v1;

import "google/protobuf/timestamp.proto";

// ExecutorService defines the execution layer interface for EVNode
service ExecutorService {
  // InitChain initializes a new blockchain instance with genesis parameters
  rpc InitChain(InitChainRequest) returns (InitChainResponse) {}

  // GetTxs fetches available transactions from the execution layer's mempool
  rpc GetTxs(GetTxsRequest) returns (GetTxsResponse) {}

  // ExecuteTxs processes transactions to produce a new block state
  rpc ExecuteTxs(ExecuteTxsRequest) returns (ExecuteTxsResponse) {}

  // SetFinal marks a block as finalized at the specified height
  rpc SetFinal(SetFinalRequest) returns (SetFinalResponse) {}

  // GetExecutionInfo returns current execution layer parameters
  rpc GetExecutionInfo(GetExecutionInfoRequest) returns (GetExecutionInfoResponse) {}

  // FilterTxs validates force-included transactions and calculates gas for all transactions
  rpc FilterTxs(FilterTxsRequest) returns (FilterTxsResponse) {}
}

// InitChainRequest contains the genesis parameters for chain initialization
message InitChainRequest {
  // Timestamp marking chain start time in UTC
  google.protobuf.Timestamp genesis_time = 1;

  // First block height (must be > 0)
  uint64 initial_height = 2;

  // Unique identifier string for the blockchain
  string chain_id = 3;
}

// InitChainResponse contains the initial state and configuration
message InitChainResponse {
  // Hash representing initial state
  bytes state_root = 1;
}

// GetTxsRequest is the request for fetching transactions
message GetTxsRequest {
  // Empty for now, may include filtering criteria in the future
}

// GetTxsResponse contains the available transactions
message GetTxsResponse {
  // Slice of valid transactions from mempool
  repeated bytes txs = 1;
}

// ExecuteTxsRequest contains transactions and block context for execution
message ExecuteTxsRequest {
  // Ordered list of transactions to execute
  repeated bytes txs = 1;

  // Height of block being created (must be > 0)
  uint64 block_height = 2;

  // Block creation time in UTC
  google.protobuf.Timestamp timestamp = 3;

  // Previous block's state root hash
  bytes prev_state_root = 4;
}

// ExecuteTxsResponse contains the result of transaction execution
message ExecuteTxsResponse {
  // New state root after executing transactions
  bytes updated_state_root = 1;

  // Maximum allowed transaction size (may change with protocol updates)
  uint64 max_bytes = 2;
}

// SetFinalRequest marks a block as finalized
message SetFinalRequest {
  // Height of block to finalize
  uint64 block_height = 1;
}

// SetFinalResponse indicates whether finalization was successful
message SetFinalResponse {
  // Empty response, errors are returned via gRPC status
}

// GetExecutionInfoRequest requests execution layer parameters
message GetExecutionInfoRequest {}

// GetExecutionInfoResponse contains execution layer parameters
message GetExecutionInfoResponse {
  // Maximum gas allowed for transactions in a block
  // For non-gas-based execution layers, this should be 0
  uint64 max_gas = 1;
}

// FilterStatus represents the result of filtering a transaction
enum FilterStatus {
  // Transaction will make it to the next batch
  FILTER_OK = 0;
  // Transaction will be filtered out because invalid (too big, malformed, etc.)
  FILTER_REMOVE = 1;
  // Transaction is valid but postponed for later processing due to size/gas constraint
  FILTER_POSTPONE = 2;
}

// FilterTxsRequest contains transactions to validate and filter
message FilterTxsRequest {
  // All transactions (force-included + mempool)
  repeated bytes txs = 1;

  // Maximum cumulative size allowed (0 means no size limit)
  uint64 max_bytes = 2;

  // Maximum cumulative gas allowed (0 means no gas limit)
  uint64 max_gas = 3;

  // Whether force-included transactions are present
  bool has_force_included_transaction = 4;
}

// FilterTxsResponse contains the filter status for each transaction
message FilterTxsResponse {
  // Filter status for each transaction (same length as txs in request)
  repeated FilterStatus statuses = 1;
}
