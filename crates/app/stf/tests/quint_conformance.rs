//! Conformance tests: replay Quint ITF traces against the real STF.
//!
//! This test reads ITF (Informal Trace Format) JSON files generated by
//! `quint test specs/stf.qnt --out-itf ...` and replays each trace against
//! the actual STF implementation, asserting that the real execution matches
//! the spec's expected outcomes.
//!
//! Run: `cargo test -p evolve_stf --test quint_conformance`
//! Regenerate traces: `quint test specs/stf.qnt --out-itf "specs/traces/out_{test}_{seq}.itf.json"`

use borsh::{BorshDeserialize, BorshSerialize};
use evolve_core::runtime_api::ACCOUNT_IDENTIFIER_PREFIX;
use evolve_core::storage_api::{StorageSetRequest, STORAGE_ACCOUNT_ID};
use evolve_core::{
    AccountCode, AccountId, BlockContext, Environment, EnvironmentQuery, ErrorCode, FungibleAsset,
    InvokableMessage, InvokeRequest, InvokeResponse, Message, ReadonlyKV, SdkResult,
};
use evolve_stf::gas::StorageGasConfig;
use evolve_stf::Stf;
use evolve_stf_traits::{
    AccountsCodeStorage, BeginBlocker, Block as BlockTrait, EndBlocker, PostTxExecution,
    StateChange, Transaction, TxValidator, WritableKV,
};
use hashbrown::HashMap;
use serde::Deserialize;
use std::fs;
use std::path::Path;

// ---------------------------------------------------------------------------
// ITF deserialization types
// ---------------------------------------------------------------------------

#[derive(Deserialize)]
struct ItfTrace {
    states: Vec<ItfState>,
}

#[derive(Deserialize)]
struct ItfState {
    block_height: ItfBigInt,
    last_result: ItfBlockResult,
    storage: ItfMap<ItfBigInt, ItfMap<Vec<ItfBigInt>, Vec<ItfBigInt>>>,
}

#[derive(Deserialize, Clone, Debug)]
struct ItfBigInt {
    #[serde(rename = "#bigint")]
    value: String,
}

impl ItfBigInt {
    fn as_i64(&self) -> i64 {
        self.value.parse().unwrap()
    }
    fn as_u64(&self) -> u64 {
        self.value.parse().unwrap()
    }
}

#[derive(Deserialize)]
struct ItfMap<K, V> {
    #[serde(rename = "#map")]
    entries: Vec<(K, V)>,
}

#[derive(Deserialize)]
struct ItfBlockResult {
    gas_used: ItfBigInt,
    tx_results: Vec<ItfTxResult>,
    txs_skipped: ItfBigInt,
}

#[derive(Deserialize)]
struct ItfTxResult {
    gas_used: ItfBigInt,
    result: ItfResult,
}

#[derive(Deserialize)]
struct ItfResult {
    ok: bool,
    err_code: ItfBigInt,
}

// ---------------------------------------------------------------------------
// STF test infrastructure (mirrors model_tests in lib.rs)
// ---------------------------------------------------------------------------

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
struct TestMsg {
    key: Vec<u8>,
    value: Vec<u8>,
    fail_after_write: bool,
}

impl InvokableMessage for TestMsg {
    const FUNCTION_IDENTIFIER: u64 = 1;
    const FUNCTION_IDENTIFIER_NAME: &'static str = "test_exec";
}

#[derive(Clone, Debug)]
struct TestTx {
    sender: AccountId,
    recipient: AccountId,
    request: InvokeRequest,
    gas_limit: u64,
    funds: Vec<FungibleAsset>,
    fail_validate: bool,
}

impl Transaction for TestTx {
    fn sender(&self) -> AccountId {
        self.sender
    }
    fn recipient(&self) -> AccountId {
        self.recipient
    }
    fn request(&self) -> &InvokeRequest {
        &self.request
    }
    fn gas_limit(&self) -> u64 {
        self.gas_limit
    }
    fn funds(&self) -> &[FungibleAsset] {
        &self.funds
    }
    fn compute_identifier(&self) -> [u8; 32] {
        [0u8; 32]
    }
}

#[derive(Clone)]
struct TestBlock {
    height: u64,
    time: u64,
    txs: Vec<TestTx>,
    gas_limit: u64,
}

impl BlockTrait<TestTx> for TestBlock {
    fn context(&self) -> BlockContext {
        BlockContext::new(self.height, self.time)
    }
    fn txs(&self) -> &[TestTx] {
        &self.txs
    }
    fn gas_limit(&self) -> u64 {
        self.gas_limit
    }
}

#[derive(Default)]
struct NoopBegin;
impl BeginBlocker<TestBlock> for NoopBegin {
    fn begin_block(&self, _block: &TestBlock, _env: &mut dyn Environment) {}
}

#[derive(Default)]
struct NoopEnd;
impl EndBlocker for NoopEnd {
    fn end_block(&self, _env: &mut dyn Environment) {}
}

#[derive(Default)]
struct Validator;
impl TxValidator<TestTx> for Validator {
    fn validate_tx(&self, tx: &TestTx, _env: &mut dyn Environment) -> SdkResult<()> {
        if tx.fail_validate {
            return Err(ErrorCode::new(100));
        }
        Ok(())
    }
}

#[derive(Default)]
struct NoopPostTx;
impl PostTxExecution<TestTx> for NoopPostTx {
    fn after_tx_executed(
        _tx: &TestTx,
        _gas_consumed: u64,
        _tx_result: &SdkResult<InvokeResponse>,
        _env: &mut dyn Environment,
    ) -> SdkResult<()> {
        Ok(())
    }
}

#[derive(Default)]
struct TestAccount;

impl AccountCode for TestAccount {
    fn identifier(&self) -> String {
        "test_account".to_string()
    }
    fn schema(&self) -> evolve_core::schema::AccountSchema {
        evolve_core::schema::AccountSchema::new("TestAccount", "test_account")
    }
    fn init(
        &self,
        _env: &mut dyn Environment,
        _request: &InvokeRequest,
    ) -> SdkResult<InvokeResponse> {
        InvokeResponse::new(&())
    }
    fn execute(
        &self,
        env: &mut dyn Environment,
        request: &InvokeRequest,
    ) -> SdkResult<InvokeResponse> {
        let msg: TestMsg = request.get()?;
        let set = StorageSetRequest {
            key: msg.key.clone(),
            value: Message::from_bytes(msg.value.clone()),
        };
        env.do_exec(STORAGE_ACCOUNT_ID, &InvokeRequest::new(&set)?, vec![])?;
        if msg.fail_after_write {
            return Err(ErrorCode::new(200));
        }
        InvokeResponse::new(&())
    }
    fn query(
        &self,
        _env: &mut dyn EnvironmentQuery,
        _request: &InvokeRequest,
    ) -> SdkResult<InvokeResponse> {
        InvokeResponse::new(&())
    }
}

struct CodeStore {
    codes: HashMap<String, Box<dyn AccountCode>>,
}

impl CodeStore {
    fn new() -> Self {
        Self {
            codes: HashMap::new(),
        }
    }
    fn add_code(&mut self, code: impl AccountCode + 'static) {
        self.codes.insert(code.identifier(), Box::new(code));
    }
}

impl AccountsCodeStorage for CodeStore {
    fn with_code<F, R>(&self, identifier: &str, f: F) -> Result<R, ErrorCode>
    where
        F: FnOnce(Option<&dyn AccountCode>) -> R,
    {
        Ok(f(self.codes.get(identifier).map(|c| c.as_ref())))
    }
    fn list_identifiers(&self) -> Vec<String> {
        self.codes.keys().cloned().collect()
    }
}

#[derive(Default)]
struct InMemoryStorage {
    data: HashMap<Vec<u8>, Vec<u8>>,
}

impl ReadonlyKV for InMemoryStorage {
    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, ErrorCode> {
        Ok(self.data.get(key).cloned())
    }
}

impl WritableKV for InMemoryStorage {
    fn apply_changes(&mut self, changes: Vec<StateChange>) -> Result<(), ErrorCode> {
        for change in changes {
            match change {
                StateChange::Set { key, value } => {
                    self.data.insert(key, value);
                }
                StateChange::Remove { key } => {
                    self.data.remove(&key);
                }
            }
        }
        Ok(())
    }
}

fn account_code_key(account: AccountId) -> Vec<u8> {
    let mut out = vec![ACCOUNT_IDENTIFIER_PREFIX];
    out.extend_from_slice(&account.as_bytes());
    out
}

fn account_storage_key(account: AccountId, key: &[u8]) -> Vec<u8> {
    let mut out = account.as_bytes();
    out.extend_from_slice(key);
    out
}

// ---------------------------------------------------------------------------
// Test case definitions (must match the Quint spec's run declarations)
// ---------------------------------------------------------------------------

const SPEC_ERR_OUT_OF_GAS: i64 = 0x01;
const SPEC_ERR_VALIDATION: i64 = 100;
const SPEC_ERR_EXECUTION: i64 = 200;

fn make_tx(
    sender: u128,
    recipient: u128,
    key: Vec<u8>,
    value: Vec<u8>,
    gas_limit: u64,
    fail_validate: bool,
    fail_execute: bool,
) -> TestTx {
    let msg = TestMsg {
        key,
        value,
        fail_after_write: fail_execute,
    };
    TestTx {
        sender: AccountId::new(sender),
        recipient: AccountId::new(recipient),
        request: InvokeRequest::new(&msg).unwrap(),
        gas_limit,
        funds: vec![],
        fail_validate,
    }
}

fn known_test_cases() -> Vec<(&'static str, TestBlock)> {
    vec![
        (
            "emptyBlockTest",
            TestBlock { height: 1, time: 0, txs: vec![], gas_limit: 1_000_000 },
        ),
        (
            "successfulTxTest",
            TestBlock {
                height: 1, time: 0, gas_limit: 1_000_000,
                txs: vec![make_tx(200, 100, vec![1], vec![11], 10000, false, false)],
            },
        ),
        (
            "validationFailureTest",
            TestBlock {
                height: 1, time: 0, gas_limit: 1_000_000,
                txs: vec![make_tx(200, 100, vec![1], vec![11], 10000, true, false)],
            },
        ),
        (
            "executionFailureRollbackTest",
            TestBlock {
                height: 1, time: 0, gas_limit: 1_000_000,
                txs: vec![make_tx(200, 100, vec![1], vec![11], 10000, false, true)],
            },
        ),
        (
            "outOfGasTest",
            TestBlock {
                height: 1, time: 0, gas_limit: 1_000_000,
                txs: vec![make_tx(200, 100, vec![1], vec![11], 1, false, false)],
            },
        ),
        (
            "blockGasLimitTest",
            TestBlock {
                height: 1, time: 0, gas_limit: 30,
                txs: vec![
                    make_tx(200, 100, vec![1], vec![11], 25, false, false),
                    make_tx(200, 100, vec![2], vec![12], 25, false, false),
                ],
            },
        ),
        (
            "mixedOutcomesTest",
            TestBlock {
                height: 1, time: 0, gas_limit: 1_000_000,
                txs: vec![
                    make_tx(200, 100, vec![0], vec![10], 10000, false, false),
                    make_tx(200, 100, vec![1], vec![11], 10000, true, false),
                    make_tx(200, 100, vec![2], vec![12], 10000, false, true),
                    make_tx(200, 100, vec![3], vec![13], 1, false, false),
                ],
            },
        ),
        (
            "overwriteTest",
            TestBlock {
                height: 1, time: 0, gas_limit: 1_000_000,
                txs: vec![
                    make_tx(200, 100, vec![1], vec![20], 10000, false, false),
                    make_tx(200, 100, vec![1], vec![21], 10000, false, false),
                ],
            },
        ),
    ]
}

// ---------------------------------------------------------------------------
// Conformance test
// ---------------------------------------------------------------------------

#[test]
fn quint_itf_conformance() {
    let traces_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../../specs/traces");

    if !traces_dir.exists() {
        panic!(
            "ITF traces not found at {}. \
             Run: quint test specs/stf.qnt \
             --out-itf \"specs/traces/out_{{test}}_{{seq}}.itf.json\"",
            traces_dir.display()
        );
    }

    let test_cases = known_test_cases();
    let mut matched = 0;

    for (test_name, block) in &test_cases {
        // Find the trace file for this test.
        let trace_file = fs::read_dir(&traces_dir)
            .unwrap()
            .filter_map(|e| e.ok())
            .find(|e| {
                let name = e.file_name().to_string_lossy().to_string();
                name.contains(test_name) && name.ends_with(".itf.json")
            });

        let trace_file = match trace_file {
            Some(f) => f,
            None => {
                eprintln!("SKIP: no trace file for {test_name}");
                continue;
            }
        };

        let trace_json = fs::read_to_string(trace_file.path()).unwrap();
        let trace: ItfTrace = serde_json::from_str(&trace_json).unwrap();

        // Find the state after apply_block (block_height > 0).
        let spec_state = trace
            .states
            .iter()
            .find(|s| s.block_height.as_i64() > 0)
            .unwrap_or_else(|| panic!("{test_name}: no apply_block state in trace"));

        let spec_result = &spec_state.last_result;

        // Set up STF with gas_config matching the spec (all charges = 1).
        let gas_config = StorageGasConfig {
            storage_get_charge: 1,
            storage_set_charge: 1,
            storage_remove_charge: 1,
        };
        let stf = Stf::new(NoopBegin, NoopEnd, Validator, NoopPostTx, gas_config);

        let mut storage = InMemoryStorage::default();
        let mut codes = CodeStore::new();
        codes.add_code(TestAccount);

        // Register account 100 (matches spec's register_account(100)).
        let test_account = AccountId::new(100);
        let code_id = "test_account".to_string();
        storage.data.insert(
            account_code_key(test_account),
            Message::new(&code_id).unwrap().into_bytes().unwrap(),
        );

        // Execute.
        let (real_result, exec_state) = stf.apply_block(&storage, &codes, block);
        storage
            .apply_changes(exec_state.into_changes().unwrap())
            .unwrap();

        // --- Assert conformance ---

        // 1. tx_results count.
        assert_eq!(
            real_result.tx_results.len(),
            spec_result.tx_results.len(),
            "{test_name}: tx_results count mismatch"
        );

        // 2. Per-tx outcomes.
        for (i, (real_tx, spec_tx)) in real_result
            .tx_results
            .iter()
            .zip(spec_result.tx_results.iter())
            .enumerate()
        {
            let spec_ok = spec_tx.result.ok;
            let real_ok = real_tx.response.is_ok();
            assert_eq!(
                real_ok, spec_ok,
                "{test_name} tx[{i}]: ok mismatch (real={real_ok}, spec={spec_ok})"
            );

            if !spec_ok {
                let spec_err = spec_tx.result.err_code.as_i64();
                let real_err = real_tx.response.as_ref().unwrap_err().id;
                match spec_err {
                    SPEC_ERR_OUT_OF_GAS => assert_eq!(
                        real_err,
                        evolve_stf::ERR_OUT_OF_GAS.id,
                        "{test_name} tx[{i}]: expected OOG"
                    ),
                    SPEC_ERR_VALIDATION => assert_eq!(
                        real_err, 100,
                        "{test_name} tx[{i}]: expected validation error"
                    ),
                    SPEC_ERR_EXECUTION => assert_eq!(
                        real_err, 200,
                        "{test_name} tx[{i}]: expected execution error"
                    ),
                    _ => {}
                }
            }

            // 3. Gas must match exactly.
            assert_eq!(
                real_tx.gas_used,
                spec_tx.gas_used.as_u64(),
                "{test_name} tx[{i}]: gas_used mismatch"
            );
        }

        // 4. Block-level gas.
        assert_eq!(
            real_result.gas_used,
            spec_result.gas_used.as_u64(),
            "{test_name}: block gas_used mismatch"
        );

        // 5. Skipped count.
        assert_eq!(
            real_result.txs_skipped,
            spec_result.txs_skipped.as_u64() as usize,
            "{test_name}: txs_skipped mismatch"
        );

        // 6. Storage state.
        for (account_id_itf, account_store_itf) in &spec_state.storage.entries {
            let account_id = AccountId::new(account_id_itf.as_u64() as u128);
            for (key_itf, value_itf) in &account_store_itf.entries {
                let key: Vec<u8> = key_itf.iter().map(|b| b.as_u64() as u8).collect();
                let value: Vec<u8> = value_itf.iter().map(|b| b.as_u64() as u8).collect();
                let storage_key = account_storage_key(account_id, &key);
                let real_value = storage.data.get(&storage_key);
                assert_eq!(
                    real_value.map(|v| v.as_slice()),
                    Some(value.as_slice()),
                    "{test_name}: storage mismatch for account {account_id:?} key {key:?}",
                );
            }
        }

        matched += 1;
        eprintln!("PASS: {test_name}");
    }

    assert!(
        matched > 0,
        "No trace files matched. Regenerate with: \
         quint test specs/stf.qnt \
         --out-itf \"specs/traces/out_{{test}}_{{seq}}.itf.json\""
    );
    eprintln!("{matched}/{} conformance tests passed", test_cases.len());
}
