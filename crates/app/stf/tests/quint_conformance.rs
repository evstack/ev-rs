//! Conformance tests: replay Quint ITF traces against the real STF.
//!
//! This test reads ITF (Informal Trace Format) JSON files generated by
//! `quint test specs/stf_core.qnt --out-itf ...` and replays each trace against
//! the actual STF implementation, asserting that the real execution matches
//! the spec's expected outcomes.
//!
//! Run: `cargo test -p evolve_stf --test quint_conformance`
//! Regenerate traces: `quint test --main=stf specs/stf_core.qnt --out-itf "specs/traces/out_{test}_{seq}.itf.json"`

use borsh::{BorshDeserialize, BorshSerialize};
use evolve_core::storage_api::{StorageSetRequest, STORAGE_ACCOUNT_ID};
use evolve_core::{
    AccountCode, AccountId, BlockContext, Environment, EnvironmentQuery, ErrorCode, FungibleAsset,
    InvokableMessage, InvokeRequest, InvokeResponse, Message, SdkResult,
};
use evolve_stf::gas::StorageGasConfig;
use evolve_stf::Stf;
use evolve_stf_traits::{
    Block as BlockTrait, PostTxExecution, SenderBootstrap, Transaction, TxValidator, WritableKV,
};
use hashbrown::HashMap;
use serde::Deserialize;
use std::path::Path;

mod quint_common;
use quint_common::{
    account_code_key, find_single_trace_file, read_itf_trace, CodeStore, InMemoryStorage,
    ItfBigInt, ItfMap, NoopBegin, NoopEnd,
};

// ---------------------------------------------------------------------------
// ITF deserialization types
// ---------------------------------------------------------------------------

#[derive(Deserialize)]
struct ItfTrace {
    states: Vec<ItfState>,
}

#[derive(Deserialize)]
struct ItfState {
    block_height: ItfBigInt,
    last_result: ItfBlockResult,
    #[allow(dead_code)]
    last_block_tx_count: ItfBigInt,
    storage: ItfMap<ItfBigInt, ItfMap<Vec<ItfBigInt>, Vec<ItfBigInt>>>,
}

#[derive(Deserialize)]
struct ItfBlockResult {
    gas_used: ItfBigInt,
    tx_results: Vec<ItfTxResult>,
    txs_skipped: ItfBigInt,
}

#[derive(Deserialize)]
struct ItfTxResult {
    gas_used: ItfBigInt,
    result: ItfResult,
}

#[derive(Deserialize)]
struct ItfResult {
    ok: bool,
    err_code: ItfBigInt,
}

// ---------------------------------------------------------------------------
// STF test infrastructure (mirrors model_tests in lib.rs)
// ---------------------------------------------------------------------------

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
struct TestMsg {
    key: Vec<u8>,
    value: Vec<u8>,
    fail_after_write: bool,
}

impl InvokableMessage for TestMsg {
    const FUNCTION_IDENTIFIER: u64 = 1;
    const FUNCTION_IDENTIFIER_NAME: &'static str = "test_msg";
}

#[derive(Clone, Debug)]
struct TestTx {
    sender: AccountId,
    recipient: AccountId,
    request: InvokeRequest,
    gas_limit: u64,
    funds: Vec<FungibleAsset>,
    fail_validate: bool,
    needs_bootstrap: bool,
    fail_bootstrap: bool,
}

impl Transaction for TestTx {
    fn sender(&self) -> AccountId {
        self.sender
    }
    fn recipient(&self) -> AccountId {
        self.recipient
    }
    fn request(&self) -> &InvokeRequest {
        &self.request
    }
    fn gas_limit(&self) -> u64 {
        self.gas_limit
    }
    fn funds(&self) -> &[FungibleAsset] {
        &self.funds
    }
    fn compute_identifier(&self) -> [u8; 32] {
        [0u8; 32]
    }
    fn sender_bootstrap(&self) -> Option<SenderBootstrap> {
        if !self.needs_bootstrap {
            return None;
        }
        let init = BootstrapInit {
            fail: self.fail_bootstrap,
        };
        let init_message =
            Message::new(&init).expect("bootstrap init serialization must succeed in tests");
        Some(SenderBootstrap {
            account_code_id: "test_account",
            init_message,
        })
    }
}

#[derive(Clone)]
struct TestBlock {
    height: u64,
    time: u64,
    txs: Vec<TestTx>,
    gas_limit: u64,
}

impl BlockTrait<TestTx> for TestBlock {
    fn context(&self) -> BlockContext {
        BlockContext::new(self.height, self.time)
    }
    fn txs(&self) -> &[TestTx] {
        &self.txs
    }
    fn gas_limit(&self) -> u64 {
        self.gas_limit
    }
}

#[derive(Default)]
struct Validator;
impl TxValidator<TestTx> for Validator {
    fn validate_tx(&self, tx: &TestTx, env: &mut dyn Environment) -> SdkResult<()> {
        if tx.fail_validate {
            return Err(ErrorCode::new(100));
        }
        // Simulate production signature verification: query the sender's
        // account code. If the sender is not registered this fails, mirroring
        // the real validator that cannot verify signatures without account code.
        let probe = TestMsg {
            key: vec![],
            value: vec![],
            fail_after_write: false,
        };
        env.do_query(tx.sender(), &InvokeRequest::new(&probe).unwrap())
            .map_err(|_| ErrorCode::new(100))?;
        Ok(())
    }
}

#[derive(Default)]
struct NoopPostTx;
impl PostTxExecution<TestTx> for NoopPostTx {
    fn after_tx_executed(
        _tx: &TestTx,
        _gas_consumed: u64,
        _tx_result: &SdkResult<InvokeResponse>,
        _env: &mut dyn Environment,
    ) -> SdkResult<()> {
        Ok(())
    }
}

#[derive(Default)]
struct TestAccount;

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
struct BootstrapInit {
    fail: bool,
}

impl AccountCode for TestAccount {
    fn identifier(&self) -> String {
        "test_account".to_string()
    }
    fn schema(&self) -> evolve_core::schema::AccountSchema {
        evolve_core::schema::AccountSchema::new("TestAccount", "test_account")
    }
    fn init(
        &self,
        _env: &mut dyn Environment,
        request: &InvokeRequest,
    ) -> SdkResult<InvokeResponse> {
        let init: BootstrapInit = request.get()?;
        if init.fail {
            return Err(ErrorCode::new(300));
        }
        InvokeResponse::new(&())
    }
    fn execute(
        &self,
        env: &mut dyn Environment,
        request: &InvokeRequest,
    ) -> SdkResult<InvokeResponse> {
        let msg: TestMsg = request.get()?;
        let set = StorageSetRequest {
            key: msg.key.clone(),
            value: Message::from_bytes(msg.value.clone()),
        };
        env.do_exec(STORAGE_ACCOUNT_ID, &InvokeRequest::new(&set)?, vec![])?;
        if msg.fail_after_write {
            return Err(ErrorCode::new(200));
        }
        InvokeResponse::new(&())
    }
    fn query(
        &self,
        _env: &mut dyn EnvironmentQuery,
        _request: &InvokeRequest,
    ) -> SdkResult<InvokeResponse> {
        InvokeResponse::new(&())
    }
}

// ---------------------------------------------------------------------------
// Test case definitions (must match the Quint spec's run declarations)
// ---------------------------------------------------------------------------

const SPEC_ERR_OUT_OF_GAS: i64 = 0x01;
const SPEC_ERR_VALIDATION: i64 = 100;
const SPEC_ERR_EXECUTION: i64 = 200;
const SPEC_ERR_BOOTSTRAP: i64 = 300;

const TEST_ACCOUNT: u128 = 100;
const TEST_SENDER: u128 = 200;

struct TxCase {
    sender: u128,
    recipient: u128,
    key: Vec<u8>,
    value: Vec<u8>,
    gas_limit: u64,
    fail_validate: bool,
    fail_execute: bool,
    needs_bootstrap: bool,
    fail_bootstrap: bool,
}

fn make_tx(tc: TxCase) -> TestTx {
    let msg = TestMsg {
        key: tc.key,
        value: tc.value,
        fail_after_write: tc.fail_execute,
    };
    TestTx {
        sender: AccountId::new(tc.sender),
        recipient: AccountId::new(tc.recipient),
        request: InvokeRequest::new(&msg).unwrap(),
        gas_limit: tc.gas_limit,
        funds: vec![],
        fail_validate: tc.fail_validate,
        needs_bootstrap: tc.needs_bootstrap,
        fail_bootstrap: tc.fail_bootstrap,
    }
}

struct ConformanceCase {
    test_name: &'static str,
    blocks: Vec<TestBlock>,
}

fn known_test_cases() -> Vec<ConformanceCase> {
    vec![
        ConformanceCase {
            test_name: "emptyBlockTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                txs: vec![],
                gas_limit: 1_000_000,
            }],
        },
        // sender=TEST_ACCOUNT (registered) for all non-bootstrap tests
        ConformanceCase {
            test_name: "successfulTxTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![make_tx(TxCase {
                    sender: TEST_ACCOUNT,
                    recipient: TEST_ACCOUNT,
                    key: vec![1],
                    value: vec![11],
                    gas_limit: 10000,
                    fail_validate: false,
                    fail_execute: false,
                    needs_bootstrap: false,
                    fail_bootstrap: false,
                })],
            }],
        },
        ConformanceCase {
            test_name: "validationFailureTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![make_tx(TxCase {
                    sender: TEST_ACCOUNT,
                    recipient: TEST_ACCOUNT,
                    key: vec![1],
                    value: vec![11],
                    gas_limit: 10000,
                    fail_validate: true,
                    fail_execute: false,
                    needs_bootstrap: false,
                    fail_bootstrap: false,
                })],
            }],
        },
        ConformanceCase {
            test_name: "executionFailureRollbackTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![make_tx(TxCase {
                    sender: TEST_ACCOUNT,
                    recipient: TEST_ACCOUNT,
                    key: vec![1],
                    value: vec![11],
                    gas_limit: 10000,
                    fail_validate: false,
                    fail_execute: true,
                    needs_bootstrap: false,
                    fail_bootstrap: false,
                })],
            }],
        },
        ConformanceCase {
            test_name: "outOfGasTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![make_tx(TxCase {
                    sender: TEST_ACCOUNT,
                    recipient: TEST_ACCOUNT,
                    key: vec![1],
                    value: vec![11],
                    gas_limit: 1,
                    fail_validate: false,
                    fail_execute: false,
                    needs_bootstrap: false,
                    fail_bootstrap: false,
                })],
            }],
        },
        ConformanceCase {
            test_name: "blockGasLimitTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 30,
                txs: vec![
                    make_tx(TxCase {
                        sender: TEST_ACCOUNT,
                        recipient: TEST_ACCOUNT,
                        key: vec![1],
                        value: vec![11],
                        gas_limit: 25,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                    make_tx(TxCase {
                        sender: TEST_ACCOUNT,
                        recipient: TEST_ACCOUNT,
                        key: vec![2],
                        value: vec![12],
                        gas_limit: 25,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                ],
            }],
        },
        ConformanceCase {
            test_name: "mixedOutcomesTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![
                    make_tx(TxCase {
                        sender: TEST_ACCOUNT,
                        recipient: TEST_ACCOUNT,
                        key: vec![0],
                        value: vec![10],
                        gas_limit: 10000,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                    make_tx(TxCase {
                        sender: TEST_ACCOUNT,
                        recipient: TEST_ACCOUNT,
                        key: vec![1],
                        value: vec![11],
                        gas_limit: 10000,
                        fail_validate: true,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                    make_tx(TxCase {
                        sender: TEST_ACCOUNT,
                        recipient: TEST_ACCOUNT,
                        key: vec![2],
                        value: vec![12],
                        gas_limit: 10000,
                        fail_validate: false,
                        fail_execute: true,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                    make_tx(TxCase {
                        sender: TEST_ACCOUNT,
                        recipient: TEST_ACCOUNT,
                        key: vec![3],
                        value: vec![13],
                        gas_limit: 1,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                ],
            }],
        },
        ConformanceCase {
            test_name: "bootstrapTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![make_tx(TxCase {
                    sender: TEST_SENDER,
                    recipient: TEST_ACCOUNT,
                    key: vec![1],
                    value: vec![11],
                    gas_limit: 10000,
                    fail_validate: false,
                    fail_execute: false,
                    needs_bootstrap: true,
                    fail_bootstrap: false,
                })],
            }],
        },
        ConformanceCase {
            test_name: "bootstrapFailureTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![make_tx(TxCase {
                    sender: TEST_SENDER,
                    recipient: TEST_ACCOUNT,
                    key: vec![1],
                    value: vec![11],
                    gas_limit: 10000,
                    fail_validate: false,
                    fail_execute: false,
                    needs_bootstrap: true,
                    fail_bootstrap: true,
                })],
            }],
        },
        // unregisteredSenderTest: sender=200 (not registered), no bootstrap
        // Validator queries sender account for sig verification -> fails
        ConformanceCase {
            test_name: "unregisteredSenderTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![make_tx(TxCase {
                    sender: TEST_SENDER,
                    recipient: TEST_ACCOUNT,
                    key: vec![1],
                    value: vec![11],
                    gas_limit: 10000,
                    fail_validate: false,
                    fail_execute: false,
                    needs_bootstrap: false,
                    fail_bootstrap: false,
                })],
            }],
        },
        ConformanceCase {
            test_name: "multiBlockTest",
            blocks: vec![
                TestBlock {
                    height: 1,
                    time: 0,
                    gas_limit: 1_000_000,
                    txs: vec![make_tx(TxCase {
                        sender: TEST_ACCOUNT,
                        recipient: TEST_ACCOUNT,
                        key: vec![1],
                        value: vec![11],
                        gas_limit: 10000,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    })],
                },
                TestBlock {
                    height: 2,
                    time: 10,
                    gas_limit: 1_000_000,
                    txs: vec![make_tx(TxCase {
                        sender: TEST_ACCOUNT,
                        recipient: TEST_ACCOUNT,
                        key: vec![2],
                        value: vec![12],
                        gas_limit: 10000,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    })],
                },
            ],
        },
        ConformanceCase {
            test_name: "overwriteTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![
                    make_tx(TxCase {
                        sender: TEST_ACCOUNT,
                        recipient: TEST_ACCOUNT,
                        key: vec![1],
                        value: vec![20],
                        gas_limit: 10000,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                    make_tx(TxCase {
                        sender: TEST_ACCOUNT,
                        recipient: TEST_ACCOUNT,
                        key: vec![1],
                        value: vec![21],
                        gas_limit: 10000,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                ],
            }],
        },
    ]
}

// ---------------------------------------------------------------------------
// Conformance test
// ---------------------------------------------------------------------------

#[test]
fn quint_itf_conformance() {
    let traces_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../../specs/traces");

    if !traces_dir.exists() {
        panic!(
            "ITF traces not found at {}. \
             Run: quint test --main=stf specs/stf_core.qnt \
             --out-itf \"specs/traces/out_{{test}}_{{seq}}.itf.json\"",
            traces_dir.display()
        );
    }

    let test_cases = known_test_cases();
    let mut matched = 0;

    for case in &test_cases {
        let trace_file = find_single_trace_file(&traces_dir, case.test_name);
        let trace: ItfTrace = read_itf_trace(&trace_file);

        let expected_block_height =
            case.blocks.last().expect("case must have blocks").height as i64;
        let spec_state = trace
            .states
            .iter()
            .find(|s| s.block_height.as_i64() == expected_block_height)
            .unwrap_or_else(|| {
                panic!(
                    "{}: no trace state with block_height={expected_block_height}",
                    case.test_name
                )
            });

        let spec_result = &spec_state.last_result;

        let gas_config = StorageGasConfig {
            storage_get_charge: 1,
            storage_set_charge: 1,
            storage_remove_charge: 1,
        };
        let stf = Stf::new(
            NoopBegin::<TestBlock>::default(),
            NoopEnd,
            Validator,
            NoopPostTx,
            gas_config,
        );

        let mut storage = InMemoryStorage::default();
        let mut codes = CodeStore::new();
        codes.add_code(TestAccount);

        let test_account = AccountId::new(TEST_ACCOUNT);
        let code_id = "test_account".to_string();
        storage.data.insert(
            account_code_key(test_account),
            Message::new(&code_id).unwrap().into_bytes().unwrap(),
        );

        let mut real_result = None;
        for block in &case.blocks {
            let (result, exec_state) = stf.apply_block(&storage, &codes, block);
            storage
                .apply_changes(exec_state.into_changes().unwrap())
                .unwrap();
            real_result = Some(result);
        }
        let real_result = real_result.expect("case must run at least one block");

        // --- Assert conformance ---

        // 1. tx_results count
        assert_eq!(
            real_result.tx_results.len(),
            spec_result.tx_results.len(),
            "{}: tx_results count mismatch",
            case.test_name
        );

        // 2. Per-tx outcomes
        for (i, (real_tx, spec_tx)) in real_result
            .tx_results
            .iter()
            .zip(spec_result.tx_results.iter())
            .enumerate()
        {
            let spec_ok = spec_tx.result.ok;
            let real_ok = real_tx.response.is_ok();
            assert_eq!(
                real_ok, spec_ok,
                "{} tx[{i}]: ok mismatch (real={real_ok}, spec={spec_ok})",
                case.test_name
            );

            if !spec_ok {
                let spec_err = spec_tx.result.err_code.as_i64();
                let real_err = real_tx.response.as_ref().unwrap_err().id;
                match spec_err {
                    SPEC_ERR_OUT_OF_GAS => assert_eq!(
                        real_err,
                        evolve_stf::ERR_OUT_OF_GAS.id,
                        "{} tx[{i}]: expected OOG",
                        case.test_name
                    ),
                    SPEC_ERR_VALIDATION => assert_eq!(
                        real_err, 100,
                        "{} tx[{i}]: expected validation error",
                        case.test_name
                    ),
                    SPEC_ERR_EXECUTION => assert_eq!(
                        real_err, 200,
                        "{} tx[{i}]: expected execution error",
                        case.test_name
                    ),
                    SPEC_ERR_BOOTSTRAP => assert_eq!(
                        real_err, 300,
                        "{} tx[{i}]: expected bootstrap error",
                        case.test_name
                    ),
                    _ => panic!(
                        "{} tx[{i}]: unknown spec error code {spec_err}",
                        case.test_name
                    ),
                }
            }

            // 3. Gas
            assert_eq!(
                real_tx.gas_used,
                spec_tx.gas_used.as_u64(),
                "{} tx[{i}]: gas_used mismatch",
                case.test_name
            );
        }

        // 4. Block-level gas
        assert_eq!(
            real_result.gas_used,
            spec_result.gas_used.as_u64(),
            "{}: block gas_used mismatch",
            case.test_name
        );

        // 5. Skipped count
        assert_eq!(
            real_result.txs_skipped,
            spec_result.txs_skipped.as_u64() as usize,
            "{}: txs_skipped mismatch",
            case.test_name
        );

        // 6. Storage
        let modeled_accounts =
            [AccountId::new(TEST_ACCOUNT), AccountId::new(TEST_SENDER)];
        for account_id in modeled_accounts {
            let mut expected = HashMap::<Vec<u8>, Vec<u8>>::new();
            for (account_id_itf, account_store_itf) in &spec_state.storage.entries {
                if AccountId::new(account_id_itf.as_u64() as u128) != account_id {
                    continue;
                }
                for (key_itf, value_itf) in &account_store_itf.entries {
                    let key: Vec<u8> = key_itf.iter().map(|b| b.as_u64() as u8).collect();
                    let value: Vec<u8> =
                        value_itf.iter().map(|b| b.as_u64() as u8).collect();
                    expected.insert(key, value);
                }
            }

            let mut actual = HashMap::<Vec<u8>, Vec<u8>>::new();
            let account_prefix = account_id.as_bytes();
            for (raw_key, raw_value) in &storage.data {
                if raw_key.len() < account_prefix.len() {
                    continue;
                }
                if raw_key[..account_prefix.len()] == account_prefix {
                    actual.insert(
                        raw_key[account_prefix.len()..].to_vec(),
                        raw_value.clone(),
                    );
                }
            }
            assert_eq!(
                actual, expected,
                "{}: storage mismatch for account {:?}",
                case.test_name, account_id
            );
        }

        matched += 1;
        eprintln!("PASS: {}", case.test_name);
    }

    assert!(
        matched == test_cases.len(),
        "Matched {matched}/{} traces",
        test_cases.len()
    );
    eprintln!("{matched}/{} conformance tests passed", test_cases.len());
}
