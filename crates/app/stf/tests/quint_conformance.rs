//! Conformance tests: replay Quint ITF traces against the real STF.
//!
//! This test reads ITF (Informal Trace Format) JSON files generated by
//! `quint test specs/stf.qnt --out-itf ...` and replays each trace against
//! the actual STF implementation, asserting that the real execution matches
//! the spec's expected outcomes.
//!
//! Run: `cargo test -p evolve_stf --test quint_conformance`
//! Regenerate traces: `quint test specs/stf.qnt --out-itf "specs/traces/out_{test}_{seq}.itf.json"`

use borsh::{BorshDeserialize, BorshSerialize};
use evolve_core::runtime_api::ACCOUNT_IDENTIFIER_PREFIX;
use evolve_core::storage_api::{StorageSetRequest, STORAGE_ACCOUNT_ID};
use evolve_core::{
    AccountCode, AccountId, BlockContext, Environment, EnvironmentQuery, ErrorCode, FungibleAsset,
    InvokableMessage, InvokeRequest, InvokeResponse, Message, ReadonlyKV, SdkResult,
};
use evolve_stf::gas::StorageGasConfig;
use evolve_stf::Stf;
use evolve_stf_traits::{
    AccountsCodeStorage, BeginBlocker, Block as BlockTrait, EndBlocker, PostTxExecution,
    SenderBootstrap, StateChange, Transaction, TxValidator, WritableKV,
};
use hashbrown::HashMap;
use serde::Deserialize;
use std::fs;
use std::path::Path;

// ---------------------------------------------------------------------------
// ITF deserialization types
// ---------------------------------------------------------------------------

#[derive(Deserialize)]
struct ItfTrace {
    states: Vec<ItfState>,
}

#[derive(Deserialize)]
struct ItfState {
    block_height: ItfBigInt,
    last_result: ItfBlockResult,
    storage: ItfMap<ItfBigInt, ItfMap<Vec<ItfBigInt>, Vec<ItfBigInt>>>,
}

#[derive(Deserialize, Clone, Debug)]
struct ItfBigInt {
    #[serde(rename = "#bigint")]
    value: String,
}

impl ItfBigInt {
    fn as_i64(&self) -> i64 {
        self.value.parse().unwrap()
    }
    fn as_u64(&self) -> u64 {
        self.value.parse().unwrap()
    }
}

#[derive(Deserialize)]
struct ItfMap<K, V> {
    #[serde(rename = "#map")]
    entries: Vec<(K, V)>,
}

#[derive(Deserialize)]
struct ItfBlockResult {
    gas_used: ItfBigInt,
    tx_results: Vec<ItfTxResult>,
    txs_skipped: ItfBigInt,
}

#[derive(Deserialize)]
struct ItfTxResult {
    gas_used: ItfBigInt,
    result: ItfResult,
}

#[derive(Deserialize)]
struct ItfResult {
    ok: bool,
    err_code: ItfBigInt,
}

// ---------------------------------------------------------------------------
// STF test infrastructure (mirrors model_tests in lib.rs)
// ---------------------------------------------------------------------------

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
struct TestMsg {
    key: Vec<u8>,
    value: Vec<u8>,
    fail_after_write: bool,
}

impl InvokableMessage for TestMsg {
    const FUNCTION_IDENTIFIER: u64 = 1;
    const FUNCTION_IDENTIFIER_NAME: &'static str = "test_exec";
}

#[derive(Clone, Debug)]
struct TestTx {
    sender: AccountId,
    recipient: AccountId,
    request: InvokeRequest,
    gas_limit: u64,
    funds: Vec<FungibleAsset>,
    fail_validate: bool,
    needs_bootstrap: bool,
    fail_bootstrap: bool,
}

impl Transaction for TestTx {
    fn sender(&self) -> AccountId {
        self.sender
    }
    fn recipient(&self) -> AccountId {
        self.recipient
    }
    fn request(&self) -> &InvokeRequest {
        &self.request
    }
    fn gas_limit(&self) -> u64 {
        self.gas_limit
    }
    fn funds(&self) -> &[FungibleAsset] {
        &self.funds
    }
    fn compute_identifier(&self) -> [u8; 32] {
        [0u8; 32]
    }
    fn sender_bootstrap(&self) -> Option<SenderBootstrap> {
        if !self.needs_bootstrap {
            return None;
        }
        let init = BootstrapInit {
            fail: self.fail_bootstrap,
        };
        let init_message =
            Message::new(&init).expect("bootstrap init serialization must succeed in tests");
        Some(SenderBootstrap {
            account_code_id: "test_account",
            init_message,
        })
    }
}

#[derive(Clone)]
struct TestBlock {
    height: u64,
    time: u64,
    txs: Vec<TestTx>,
    gas_limit: u64,
}

impl BlockTrait<TestTx> for TestBlock {
    fn context(&self) -> BlockContext {
        BlockContext::new(self.height, self.time)
    }
    fn txs(&self) -> &[TestTx] {
        &self.txs
    }
    fn gas_limit(&self) -> u64 {
        self.gas_limit
    }
}

#[derive(Default)]
struct NoopBegin;
impl BeginBlocker<TestBlock> for NoopBegin {
    fn begin_block(&self, _block: &TestBlock, _env: &mut dyn Environment) {}
}

#[derive(Default)]
struct NoopEnd;
impl EndBlocker for NoopEnd {
    fn end_block(&self, _env: &mut dyn Environment) {}
}

#[derive(Default)]
struct Validator;
impl TxValidator<TestTx> for Validator {
    fn validate_tx(&self, tx: &TestTx, _env: &mut dyn Environment) -> SdkResult<()> {
        if tx.fail_validate {
            return Err(ErrorCode::new(100));
        }
        Ok(())
    }
}

#[derive(Default)]
struct NoopPostTx;
impl PostTxExecution<TestTx> for NoopPostTx {
    fn after_tx_executed(
        _tx: &TestTx,
        _gas_consumed: u64,
        _tx_result: &SdkResult<InvokeResponse>,
        _env: &mut dyn Environment,
    ) -> SdkResult<()> {
        Ok(())
    }
}

#[derive(Default)]
struct TestAccount;

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
struct BootstrapInit {
    fail: bool,
}

impl AccountCode for TestAccount {
    fn identifier(&self) -> String {
        "test_account".to_string()
    }
    fn schema(&self) -> evolve_core::schema::AccountSchema {
        evolve_core::schema::AccountSchema::new("TestAccount", "test_account")
    }
    fn init(
        &self,
        _env: &mut dyn Environment,
        request: &InvokeRequest,
    ) -> SdkResult<InvokeResponse> {
        let init: BootstrapInit = request.get()?;
        if init.fail {
            return Err(ErrorCode::new(300));
        }
        InvokeResponse::new(&())
    }
    fn execute(
        &self,
        env: &mut dyn Environment,
        request: &InvokeRequest,
    ) -> SdkResult<InvokeResponse> {
        let msg: TestMsg = request.get()?;
        let set = StorageSetRequest {
            key: msg.key.clone(),
            value: Message::from_bytes(msg.value.clone()),
        };
        env.do_exec(STORAGE_ACCOUNT_ID, &InvokeRequest::new(&set)?, vec![])?;
        if msg.fail_after_write {
            return Err(ErrorCode::new(200));
        }
        InvokeResponse::new(&())
    }
    fn query(
        &self,
        _env: &mut dyn EnvironmentQuery,
        _request: &InvokeRequest,
    ) -> SdkResult<InvokeResponse> {
        InvokeResponse::new(&())
    }
}

struct CodeStore {
    codes: HashMap<String, Box<dyn AccountCode>>,
}

impl CodeStore {
    fn new() -> Self {
        Self {
            codes: HashMap::new(),
        }
    }
    fn add_code(&mut self, code: impl AccountCode + 'static) {
        self.codes.insert(code.identifier(), Box::new(code));
    }
}

impl AccountsCodeStorage for CodeStore {
    fn with_code<F, R>(&self, identifier: &str, f: F) -> Result<R, ErrorCode>
    where
        F: FnOnce(Option<&dyn AccountCode>) -> R,
    {
        Ok(f(self.codes.get(identifier).map(|c| c.as_ref())))
    }
    fn list_identifiers(&self) -> Vec<String> {
        self.codes.keys().cloned().collect()
    }
}

#[derive(Default)]
struct InMemoryStorage {
    data: HashMap<Vec<u8>, Vec<u8>>,
}

impl ReadonlyKV for InMemoryStorage {
    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, ErrorCode> {
        Ok(self.data.get(key).cloned())
    }
}

impl WritableKV for InMemoryStorage {
    fn apply_changes(&mut self, changes: Vec<StateChange>) -> Result<(), ErrorCode> {
        for change in changes {
            match change {
                StateChange::Set { key, value } => {
                    self.data.insert(key, value);
                }
                StateChange::Remove { key } => {
                    self.data.remove(&key);
                }
            }
        }
        Ok(())
    }
}

fn account_code_key(account: AccountId) -> Vec<u8> {
    let mut out = vec![ACCOUNT_IDENTIFIER_PREFIX];
    out.extend_from_slice(&account.as_bytes());
    out
}

// ---------------------------------------------------------------------------
// Test case definitions (must match the Quint spec's run declarations)
// ---------------------------------------------------------------------------

const SPEC_ERR_OUT_OF_GAS: i64 = 0x01;
const SPEC_ERR_VALIDATION: i64 = 100;
const SPEC_ERR_EXECUTION: i64 = 200;

struct TxCase {
    sender: u128,
    recipient: u128,
    key: Vec<u8>,
    value: Vec<u8>,
    gas_limit: u64,
    fail_validate: bool,
    fail_execute: bool,
    needs_bootstrap: bool,
    fail_bootstrap: bool,
}

fn make_tx(tc: TxCase) -> TestTx {
    let msg = TestMsg {
        key: tc.key,
        value: tc.value,
        fail_after_write: tc.fail_execute,
    };
    TestTx {
        sender: AccountId::new(tc.sender),
        recipient: AccountId::new(tc.recipient),
        request: InvokeRequest::new(&msg).unwrap(),
        gas_limit: tc.gas_limit,
        funds: vec![],
        fail_validate: tc.fail_validate,
        needs_bootstrap: tc.needs_bootstrap,
        fail_bootstrap: tc.fail_bootstrap,
    }
}

const SPEC_ERR_BOOTSTRAP: i64 = 300;
const TEST_ACCOUNT: u128 = 100;
const TEST_SENDER: u128 = 200;

struct ConformanceCase {
    test_name: &'static str,
    blocks: Vec<TestBlock>,
}

fn known_test_cases() -> Vec<ConformanceCase> {
    vec![
        ConformanceCase {
            test_name: "emptyBlockTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                txs: vec![],
                gas_limit: 1_000_000,
            }],
        },
        ConformanceCase {
            test_name: "successfulTxTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![make_tx(TxCase {
                    sender: TEST_SENDER,
                    recipient: TEST_ACCOUNT,
                    key: vec![1],
                    value: vec![11],
                    gas_limit: 10000,
                    fail_validate: false,
                    fail_execute: false,
                    needs_bootstrap: false,
                    fail_bootstrap: false,
                })],
            }],
        },
        ConformanceCase {
            test_name: "validationFailureTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![make_tx(TxCase {
                    sender: TEST_SENDER,
                    recipient: TEST_ACCOUNT,
                    key: vec![1],
                    value: vec![11],
                    gas_limit: 10000,
                    fail_validate: true,
                    fail_execute: false,
                    needs_bootstrap: false,
                    fail_bootstrap: false,
                })],
            }],
        },
        ConformanceCase {
            test_name: "executionFailureRollbackTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![make_tx(TxCase {
                    sender: TEST_SENDER,
                    recipient: TEST_ACCOUNT,
                    key: vec![1],
                    value: vec![11],
                    gas_limit: 10000,
                    fail_validate: false,
                    fail_execute: true,
                    needs_bootstrap: false,
                    fail_bootstrap: false,
                })],
            }],
        },
        ConformanceCase {
            test_name: "outOfGasTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![make_tx(TxCase {
                    sender: TEST_SENDER,
                    recipient: TEST_ACCOUNT,
                    key: vec![1],
                    value: vec![11],
                    gas_limit: 1,
                    fail_validate: false,
                    fail_execute: false,
                    needs_bootstrap: false,
                    fail_bootstrap: false,
                })],
            }],
        },
        ConformanceCase {
            test_name: "blockGasLimitTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 30,
                txs: vec![
                    make_tx(TxCase {
                        sender: TEST_SENDER,
                        recipient: TEST_ACCOUNT,
                        key: vec![1],
                        value: vec![11],
                        gas_limit: 25,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                    make_tx(TxCase {
                        sender: TEST_SENDER,
                        recipient: TEST_ACCOUNT,
                        key: vec![2],
                        value: vec![12],
                        gas_limit: 25,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                ],
            }],
        },
        ConformanceCase {
            test_name: "mixedOutcomesTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![
                    make_tx(TxCase {
                        sender: TEST_SENDER,
                        recipient: TEST_ACCOUNT,
                        key: vec![0],
                        value: vec![10],
                        gas_limit: 10000,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                    make_tx(TxCase {
                        sender: TEST_SENDER,
                        recipient: TEST_ACCOUNT,
                        key: vec![1],
                        value: vec![11],
                        gas_limit: 10000,
                        fail_validate: true,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                    make_tx(TxCase {
                        sender: TEST_SENDER,
                        recipient: TEST_ACCOUNT,
                        key: vec![2],
                        value: vec![12],
                        gas_limit: 10000,
                        fail_validate: false,
                        fail_execute: true,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                    make_tx(TxCase {
                        sender: TEST_SENDER,
                        recipient: TEST_ACCOUNT,
                        key: vec![3],
                        value: vec![13],
                        gas_limit: 1,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                ],
            }],
        },
        ConformanceCase {
            test_name: "bootstrapTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![make_tx(TxCase {
                    sender: TEST_SENDER,
                    recipient: TEST_ACCOUNT,
                    key: vec![1],
                    value: vec![11],
                    gas_limit: 10000,
                    fail_validate: false,
                    fail_execute: false,
                    needs_bootstrap: true,
                    fail_bootstrap: false,
                })],
            }],
        },
        ConformanceCase {
            test_name: "bootstrapFailureTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![make_tx(TxCase {
                    sender: TEST_SENDER,
                    recipient: TEST_ACCOUNT,
                    key: vec![1],
                    value: vec![11],
                    gas_limit: 10000,
                    fail_validate: false,
                    fail_execute: false,
                    needs_bootstrap: true,
                    fail_bootstrap: true,
                })],
            }],
        },
        ConformanceCase {
            test_name: "multiBlockTest",
            blocks: vec![
                TestBlock {
                    height: 1,
                    time: 0,
                    gas_limit: 1_000_000,
                    txs: vec![make_tx(TxCase {
                        sender: TEST_SENDER,
                        recipient: TEST_ACCOUNT,
                        key: vec![1],
                        value: vec![11],
                        gas_limit: 10000,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    })],
                },
                TestBlock {
                    height: 2,
                    time: 10,
                    gas_limit: 1_000_000,
                    txs: vec![make_tx(TxCase {
                        sender: TEST_SENDER,
                        recipient: TEST_ACCOUNT,
                        key: vec![2],
                        value: vec![12],
                        gas_limit: 10000,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    })],
                },
            ],
        },
        ConformanceCase {
            test_name: "overwriteTest",
            blocks: vec![TestBlock {
                height: 1,
                time: 0,
                gas_limit: 1_000_000,
                txs: vec![
                    make_tx(TxCase {
                        sender: TEST_SENDER,
                        recipient: TEST_ACCOUNT,
                        key: vec![1],
                        value: vec![20],
                        gas_limit: 10000,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                    make_tx(TxCase {
                        sender: TEST_SENDER,
                        recipient: TEST_ACCOUNT,
                        key: vec![1],
                        value: vec![21],
                        gas_limit: 10000,
                        fail_validate: false,
                        fail_execute: false,
                        needs_bootstrap: false,
                        fail_bootstrap: false,
                    }),
                ],
            }],
        },
    ]
}

// ---------------------------------------------------------------------------
// Conformance test
// ---------------------------------------------------------------------------

#[test]
fn quint_itf_conformance() {
    let traces_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../../specs/traces");

    if !traces_dir.exists() {
        panic!(
            "ITF traces not found at {}. \
             Run: quint test specs/stf.qnt \
             --out-itf \"specs/traces/out_{{test}}_{{seq}}.itf.json\"",
            traces_dir.display()
        );
    }

    let test_cases = known_test_cases();
    let mut matched = 0;

    for case in &test_cases {
        // Find the unique trace file for this test.
        let trace_files: Vec<_> = fs::read_dir(&traces_dir)
            .unwrap()
            .filter_map(|e| e.ok())
            .filter(|e| {
                let name = e.file_name().to_string_lossy().to_string();
                name.starts_with(&format!("out_{}_", case.test_name)) && name.ends_with(".itf.json")
            })
            .collect();

        assert_eq!(
            trace_files.len(),
            1,
            "{}: expected exactly 1 trace file, found {}",
            case.test_name,
            trace_files.len()
        );
        let trace_file = &trace_files[0];

        let trace_json = fs::read_to_string(trace_file.path()).unwrap();
        let trace: ItfTrace = serde_json::from_str(&trace_json).unwrap();

        // Find the final state for this run after all apply_block steps.
        let expected_block_height =
            case.blocks.last().expect("case must have blocks").height as i64;
        let spec_state = trace
            .states
            .iter()
            .find(|s| s.block_height.as_i64() == expected_block_height)
            .unwrap_or_else(|| {
                panic!(
                    "{}: no trace state with block_height={expected_block_height}",
                    case.test_name
                )
            });

        let spec_result = &spec_state.last_result;

        // Set up STF with gas_config matching the spec (all charges = 1).
        let gas_config = StorageGasConfig {
            storage_get_charge: 1,
            storage_set_charge: 1,
            storage_remove_charge: 1,
        };
        let stf = Stf::new(NoopBegin, NoopEnd, Validator, NoopPostTx, gas_config);

        let mut storage = InMemoryStorage::default();
        let mut codes = CodeStore::new();
        codes.add_code(TestAccount);

        // Register account 100 (matches spec's register_account(100)).
        let test_account = AccountId::new(TEST_ACCOUNT);
        let code_id = "test_account".to_string();
        storage.data.insert(
            account_code_key(test_account),
            Message::new(&code_id).unwrap().into_bytes().unwrap(),
        );

        // Execute the full block sequence for this case.
        let mut real_result = None;
        for block in &case.blocks {
            let (result, exec_state) = stf.apply_block(&storage, &codes, block);
            storage
                .apply_changes(exec_state.into_changes().unwrap())
                .unwrap();
            real_result = Some(result);
        }
        let real_result = real_result.expect("case must execute at least one block");

        // --- Assert conformance ---

        // 1. tx_results count.
        assert_eq!(
            real_result.tx_results.len(),
            spec_result.tx_results.len(),
            "{}: tx_results count mismatch",
            case.test_name
        );

        // 2. Per-tx outcomes.
        for (i, (real_tx, spec_tx)) in real_result
            .tx_results
            .iter()
            .zip(spec_result.tx_results.iter())
            .enumerate()
        {
            let spec_ok = spec_tx.result.ok;
            let real_ok = real_tx.response.is_ok();
            assert_eq!(
                real_ok, spec_ok,
                "{} tx[{i}]: ok mismatch (real={real_ok}, spec={spec_ok})",
                case.test_name
            );

            if !spec_ok {
                let spec_err = spec_tx.result.err_code.as_i64();
                let real_err = real_tx.response.as_ref().unwrap_err().id;
                match spec_err {
                    SPEC_ERR_OUT_OF_GAS => assert_eq!(
                        real_err,
                        evolve_stf::ERR_OUT_OF_GAS.id,
                        "{} tx[{i}]: expected OOG",
                        case.test_name
                    ),
                    SPEC_ERR_VALIDATION => assert_eq!(
                        real_err, 100,
                        "{} tx[{i}]: expected validation error",
                        case.test_name
                    ),
                    SPEC_ERR_EXECUTION => assert_eq!(
                        real_err, 200,
                        "{} tx[{i}]: expected execution error",
                        case.test_name
                    ),
                    SPEC_ERR_BOOTSTRAP => assert_eq!(
                        real_err, 300,
                        "{} tx[{i}]: expected bootstrap error",
                        case.test_name
                    ),
                    _ => panic!(
                        "{} tx[{i}]: unknown spec error code {spec_err}",
                        case.test_name
                    ),
                }
            }

            // 3. Gas must match exactly.
            assert_eq!(
                real_tx.gas_used,
                spec_tx.gas_used.as_u64(),
                "{} tx[{i}]: gas_used mismatch",
                case.test_name
            );
        }

        // 4. Block-level gas.
        assert_eq!(
            real_result.gas_used,
            spec_result.gas_used.as_u64(),
            "{}: block gas_used mismatch",
            case.test_name
        );

        // 5. Skipped count.
        assert_eq!(
            real_result.txs_skipped,
            spec_result.txs_skipped.as_u64() as usize,
            "{}: txs_skipped mismatch",
            case.test_name
        );

        // 6. Storage state must match exactly (for modeled accounts).
        let modeled_accounts = [AccountId::new(TEST_ACCOUNT), AccountId::new(TEST_SENDER)];
        for account_id in modeled_accounts {
            let mut expected = HashMap::<Vec<u8>, Vec<u8>>::new();
            for (account_id_itf, account_store_itf) in &spec_state.storage.entries {
                if AccountId::new(account_id_itf.as_u64() as u128) != account_id {
                    continue;
                }
                for (key_itf, value_itf) in &account_store_itf.entries {
                    let key: Vec<u8> = key_itf.iter().map(|b| b.as_u64() as u8).collect();
                    let value: Vec<u8> = value_itf.iter().map(|b| b.as_u64() as u8).collect();
                    expected.insert(key, value);
                }
            }

            let mut actual = HashMap::<Vec<u8>, Vec<u8>>::new();
            let account_prefix = account_id.as_bytes();
            for (raw_key, raw_value) in &storage.data {
                if raw_key.len() < account_prefix.len() {
                    continue;
                }
                if raw_key[..account_prefix.len()] == account_prefix {
                    actual.insert(raw_key[account_prefix.len()..].to_vec(), raw_value.clone());
                }
            }
            assert_eq!(
                actual, expected,
                "{}: exact storage mismatch for account {:?}",
                case.test_name, account_id
            );
        }

        matched += 1;
        eprintln!("PASS: {}", case.test_name);
    }

    assert!(
        matched == test_cases.len(),
        "Matched {matched}/{} traces. Regenerate with: \
         quint test specs/stf.qnt \
         --out-itf \"specs/traces/out_{{test}}_{{seq}}.itf.json\"",
        test_cases.len()
    );
    eprintln!("{matched}/{} conformance tests passed", test_cases.len());
}
