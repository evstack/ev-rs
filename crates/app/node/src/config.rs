use std::error::Error;
use std::net::SocketAddr;
use std::path::Path;

use figment::providers::{Env, Format, Serialized, Yaml};
use figment::Figment;
use serde::{Deserialize, Serialize};

use crate::{RpcConfig, DEFAULT_DATA_DIR, DEFAULT_RPC_ADDR};

pub const DEFAULT_CONFIG_PATH: &str = "config.yaml";
pub const DEFAULT_GRPC_ADDR: &str = "127.0.0.1:50051";

pub type ConfigResult<T> = Result<T, Box<dyn Error + Send + Sync>>;

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(default)]
pub struct NodeConfig {
    pub chain: ChainConfig,
    pub storage: StorageNodeConfig,
    pub rpc: RpcNodeConfig,
    pub grpc: GrpcNodeConfig,
    pub operations: OperationsConfig,
    pub observability: ObservabilityConfig,
}

impl NodeConfig {
    pub fn validate(&self) -> ConfigResult<()> {
        if self.chain.chain_id == 0 {
            return Err("chain.chain_id must be > 0".into());
        }
        if self.grpc.max_message_size == 0 {
            return Err("grpc.max_message_size must be > 0".into());
        }
        if self.operations.shutdown_timeout_secs == 0 {
            return Err("operations.shutdown_timeout_secs must be > 0".into());
        }
        self.rpc
            .http_addr
            .parse::<SocketAddr>()
            .map_err(|e| format!("invalid rpc.http_addr '{}': {e}", self.rpc.http_addr))?;
        self.grpc
            .addr
            .parse::<SocketAddr>()
            .map_err(|e| format!("invalid grpc.addr '{}': {e}", self.grpc.addr))?;
        Ok(())
    }

    pub fn parsed_rpc_addr(&self) -> SocketAddr {
        self.rpc
            .http_addr
            .parse()
            .unwrap_or_else(|e| panic!("invalid rpc.http_addr '{}': {e}", self.rpc.http_addr))
    }

    pub fn parsed_grpc_addr(&self) -> SocketAddr {
        self.grpc
            .addr
            .parse()
            .unwrap_or_else(|e| panic!("invalid grpc.addr '{}': {e}", self.grpc.addr))
    }

    pub fn grpc_max_message_size_usize(&self) -> usize {
        self.grpc
            .max_message_size
            .try_into()
            .expect("grpc.max_message_size exceeds platform usize")
    }

    pub fn to_rpc_config(&self) -> RpcConfig {
        RpcConfig {
            http_addr: self.parsed_rpc_addr(),
            chain_id: self.chain.chain_id,
            enabled: self.rpc.enabled,
            enable_block_indexing: self.rpc.enable_block_indexing,
        }
    }
}

/// Build a Figment merge chain: defaults < YAML file < env vars (EVOLVE_ prefix).
pub fn build_figment(config_path: &Path) -> Figment {
    let mut figment = Figment::from(Serialized::defaults(NodeConfig::default()));
    if config_path.exists() {
        figment = figment.merge(Yaml::file(config_path));
    }
    figment.merge(Env::prefixed("EVOLVE_").split("__"))
}

pub fn write_default_config(path: &Path, force: bool) -> ConfigResult<()> {
    if path.exists() && !force {
        return Err(format!(
            "config file already exists at {} (use --force to overwrite)",
            path.display()
        )
        .into());
    }

    if let Some(parent) = path.parent().filter(|p| !p.as_os_str().is_empty()) {
        std::fs::create_dir_all(parent)?;
    }

    let yaml = serde_yaml::to_string(&NodeConfig::default())?;
    let document = format!("# Generated by Evolve\n\n{yaml}");
    std::fs::write(path, document)?;
    Ok(())
}

pub fn ensure_config_exists(path: &Path) -> ConfigResult<()> {
    if path.exists() {
        return Ok(());
    }
    write_default_config(path, false)
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct ChainConfig {
    pub chain_id: u64,
}

impl Default for ChainConfig {
    fn default() -> Self {
        Self { chain_id: 1 }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct StorageNodeConfig {
    pub path: String,
}

impl Default for StorageNodeConfig {
    fn default() -> Self {
        Self {
            path: DEFAULT_DATA_DIR.to_string(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct RpcNodeConfig {
    pub enabled: bool,
    pub http_addr: String,
    pub enable_block_indexing: bool,
}

impl Default for RpcNodeConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            http_addr: DEFAULT_RPC_ADDR.to_string(),
            enable_block_indexing: true,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct GrpcNodeConfig {
    pub addr: String,
    pub enable_gzip: bool,
    pub max_message_size: u64,
}

impl Default for GrpcNodeConfig {
    fn default() -> Self {
        Self {
            addr: DEFAULT_GRPC_ADDR.to_string(),
            enable_gzip: true,
            max_message_size: 4 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct OperationsConfig {
    pub shutdown_timeout_secs: u64,
}

impl Default for OperationsConfig {
    fn default() -> Self {
        Self {
            shutdown_timeout_secs: 10,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct ObservabilityConfig {
    pub log_level: String,
}

impl Default for ObservabilityConfig {
    fn default() -> Self {
        Self {
            log_level: "info".to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn default_config_is_valid() {
        let config = NodeConfig::default();
        config.validate().expect("default config should validate");
    }

    #[test]
    fn write_and_load_via_figment_roundtrip() {
        let dir = tempdir().expect("tempdir");
        let path = dir.path().join("config.yaml");

        write_default_config(&path, false).expect("write default config");
        let loaded: NodeConfig = build_figment(&path)
            .extract()
            .expect("figment extract failed");

        assert_eq!(loaded.chain.chain_id, 1);
        assert_eq!(loaded.storage.path, DEFAULT_DATA_DIR);
        assert_eq!(loaded.rpc.http_addr, DEFAULT_RPC_ADDR);
        assert_eq!(loaded.grpc.addr, DEFAULT_GRPC_ADDR);
    }

    #[test]
    fn write_default_config_respects_force() {
        let dir = tempdir().expect("tempdir");
        let path = dir.path().join("config.yaml");

        write_default_config(&path, false).expect("initial write");
        let err = write_default_config(&path, false).expect_err("second write should fail");
        assert!(
            err.to_string().contains("config file already exists"),
            "unexpected error: {err}"
        );

        write_default_config(&path, true).expect("force overwrite should succeed");
    }

    #[test]
    fn figment_env_overrides_yaml() {
        let dir = tempdir().expect("tempdir");
        let path = dir.path().join("config.yaml");
        write_default_config(&path, false).expect("write config");

        // Simulate env override
        let figment = build_figment(&path).merge(("chain.chain_id", 42u64));
        let config: NodeConfig = figment.extract().expect("extract");
        assert_eq!(config.chain.chain_id, 42);
    }

    #[test]
    fn validate_catches_invalid_socket_addr() {
        let mut config = NodeConfig::default();
        config.rpc.http_addr = "not-a-socket-addr".to_string();
        let err = config.validate().expect_err("should fail");
        assert!(err.to_string().contains("invalid rpc.http_addr"));
    }
}
